// Sharm - The appropriate shell for Microsoft Windows.
// Copyright (C) 2024  Max Zargov <zargovv@gmail.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#![allow(non_camel_case_types)]

use std::os::windows::raw::HANDLE;

use super::{CHAR_INFO, COORD, PINPUT_RECORD, PSMALL_RECT, SMALL_RECT};

/// Characters read by the `ReadFile` or `ReadConsole` function are written to the active screen
/// buffer as they are typed into the console. This mode can be used only if the `ENABLE_LINE_INPUT`
/// mode is also enabled.
pub(crate) const ENABLE_ECHO_INPUT: u32 = 0x0004;
/// When enabled, text entered in a console window will be inserted at the current cursor location
/// and all text following that location will not be overwritten. When disabled, all following text
/// will be overwritten.
pub(crate) const ENABLE_INSERT_MODE: u32 = 0x0020;
/// The `ReadFile` or `ReadConsole` function returns only when a carriage return character is read.
/// If this mode is disabled, the functions return when one or more characters are available.
pub(crate) const ENABLE_LINE_INPUT: u32 = 0x0002;
/// If the mouse pointer is within the borders of the console window and the window has the keyboard
/// focus, mouse events generated by mouse movement and button presses are placed in the input
/// buffer. These events are discarded by `ReadFile` or `ReadConsole`, even when this mode is
/// enabled. The `ReadConsoleInput` function can be used to read `MOUSE_EVENT` input records from
/// the input buffer.
pub(crate) const ENABLE_MOUSE_INPUT: u32 = 0x0010;
/// CTRL+C is processed by the system and is not placed in the input buffer. If the input buffer is
/// being read by `ReadFile` or `ReadConsole`, other control keys are processed by the system and
/// are not returned in the `ReadFile` or `ReadConsole` buffer. If the `ENABLE_LINE_INPUT` mode is
/// also enabled, backspace, carriage return, and line feed characters are handled by the system.
pub(crate) const ENABLE_PROCESSED_INPUT: u32 = 0x0001;
/// This flag enables the user to use the mouse to select and edit text. To enable this mode, use
/// `ENABLE_QUICK_EDIT_MODE` | `ENABLE_EXTENDED_FLAGS`. To disable this mode, use
/// `ENABLE_EXTENDED_FLAGS` without this flag.
pub(crate) const ENABLE_QUICK_EDIT_MODE: u32 = 0x0040;
/// User interactions that change the size of the console screen buffer are reported in the
/// console's input buffer. Information about these events can be read from the input buffer by
/// applications using the `ReadConsoleInput` function, but not by those using `ReadFile` or
/// `ReadConsole`.
pub(crate) const ENABLE_WINDOW_INPUT: u32 = 0x0008;
/// Setting this flag directs the Virtual Terminal processing engine to convert user input received
/// by the console window into Console Virtual Terminal Sequences that can be retrieved by a
/// supporting application through `ReadFile` or `ReadConsole` functions.
///
/// The typical usage of this flag is intended in conjunction with
/// `ENABLE_VIRTUAL_TERMINAL_PROCESSING` on the output handle to connect to an application that
/// communicates exclusively via virtual terminal sequences.
pub(crate) const ENABLE_VIRTUAL_TERMINAL_INPUT: u32 = 0x0200;

/// Characters written by the `WriteFile` or `WriteConsole` function or echoed by the `ReadFile` or
/// `ReadConsole` function are parsed for ASCII control sequences, and the correct action is
/// performed. Backspace, tab, bell, carriage return, and line feed characters are processed. It
/// should be enabled when using control sequences or when `ENABLE_VIRTUAL_TERMINAL_PROCESSING` is
/// set.
pub(crate) const ENABLE_PROCESSED_OUTPUT: u32 = 0x0001;
/// When writing with `WriteFile` or `WriteConsole` or echoing with `ReadFile` or `ReadConsole`, the
/// cursor moves to the beginning of the next row when it reaches the end of the current row. This
/// causes the rows displayed in the console window to scroll up automatically when the cursor
/// advances beyond the last row in the window. It also causes the contents of the console screen
/// buffer to scroll up (../discarding the top row of the console screen buffer) when the cursor
/// advances beyond the last row in the console screen buffer. If this mode is disabled, the last
/// character in the row is overwritten with any subsequent characters.
pub(crate) const ENABLE_WRAP_AT_EOL_OUTPUT: u32 = 0x0002;
/// When writing with `WriteFile` or `WriteConsole`, characters are parsed for VT100 and similar
/// control character sequences that control cursor movement, color/font mode, and other operations
/// that can also be performed via the existing Console APIs. For more information, see Console
/// Virtual Terminal Sequences.
///
/// Ensure `ENABLE_PROCESSED_OUTPUT` is set when using this flag.
pub(crate) const ENABLE_VIRTUAL_TERMINAL_PROCESSING: u32 = 0x0004;
/// When writing with `WriteFile` or `WriteConsole`, this adds an additional state to end-of-line
/// wrapping that can delay the cursor move and buffer scroll operations.
///
/// Normally when `ENABLE_WRAP_AT_EOL_OUTPUT` is set and text reaches the end of the line, the
/// cursor will immediately move to the next line and the contents of the buffer will scroll up by
/// one line. In contrast with this flag set, the cursor does not move to the next line, and the
/// scroll operation is not performed. The written character will be printed in the final position
/// on the line and the cursor will remain above this character as if `ENABLE_WRAP_AT_EOL_OUTPUT`
/// was off, but the next printable character will be printed as if `ENABLE_WRAP_AT_EOL_OUTPUT` is
/// on. No overwrite will occur. Specifically, the cursor quickly advances down to the following
/// line, a scroll is performed if necessary, the character is printed, and the cursor advances one
/// more position.
///
/// The typical usage of this flag is intended in conjunction with setting
/// `ENABLE_VIRTUAL_TERMINAL_PROCESSING` to better emulate a terminal emulator where writing the
/// final character on the screen (../in the bottom right corner) without triggering an immediate
/// scroll is the desired behavior.
pub(crate) const DISABLE_NEWLINE_AUTO_RETURN: u32 = 0x0008;
/// The APIs for writing character attributes including `WriteConsoleOutput` and
/// `WriteConsoleOutputAttribute` allow the usage of flags from character attributes to adjust the
/// color of the foreground and background of text. Additionally, a range of DBCS flags was
/// specified with the `COMMON_LVB` prefix. Historically, these flags only functioned in DBCS code
/// pages for Chinese, Japanese, and Korean languages.
///
/// With exception of the leading byte and trailing byte flags, the remaining flags describing line
/// drawing and reverse video (../swap foreground and background colors) can be useful for other
/// languages to emphasize portions of output.
///
/// Setting this console mode flag will allow these attributes to be used in every code page on
/// every language.
///
/// It is off by default to maintain compatibility with known applications that have historically
/// taken advantage of the console ignoring these flags on non-CJK machines to store bits in these
/// fields for their own purposes or by accident.
///
/// Note that using the `ENABLE_VIRTUAL_TERMINAL_PROCESSING` mode can result in LVB grid and reverse
/// video flags being set while this flag is still off if the attached application requests
/// underlining or inverse video via Console Virtual Terminal Sequences.
pub(crate) const ENABLE_LVB_GRID_WORLDWIDE: u32 = 0x0010;

#[repr(C)]
#[derive(Debug)]
pub(crate) struct CONSOLE_SCREEN_BUFFER_INFO {
  pub(crate) dwSize: COORD,
  pub(crate) dwCursorPosition: COORD,
  pub(crate) wAttributes: u16,
  pub(crate) srWindow: SMALL_RECT,
  pub(crate) dwMaximumWindowSize: COORD,
}
pub(crate) type PCONSOLE_SCREEN_BUFFER_INFO = *mut CONSOLE_SCREEN_BUFFER_INFO;

extern "C" {
  /// # Return value
  ///
  /// If the function fails, the return value is `INVALID_HANDLE_VALUE`. To get extended error
  /// information, call `GetLastError`.
  pub(crate) fn GetStdHandle(/* _In_ */ nStdHandle: u32) -> HANDLE;
  /// # Return value
  ///
  /// If the function succeeds, the return value is nonzero.
  ///
  /// If the function fails, the return value is zero. To get extended error information, call
  /// `GetLastError`.
  pub(crate) fn GetConsoleMode(
    /* _In_  */ hConsoleHandle: HANDLE,
    /* _Out_ */ lpMode: *mut u32,
  ) -> i32;
  pub(crate) fn SetConsoleMode(
    /* _In_ */ hConsoleHandle: HANDLE,
    /* _In_ */ dwMode: u32,
  ) -> i32;
  /// # Return value
  ///
  /// If the function succeeds, the return value is nonzero.
  ///
  /// If the function fails, the return value is zero. To get extended error information, call
  /// `GetLastError`.
  pub(crate) fn SetConsoleTitleW(/* _In_ */ lpConsoleTitle: *const u16) -> i32;
  /// # Return value
  ///
  /// If the function succeeds, the return value is nonzero.
  ///
  /// If the function fails, the return value is zero. To get extended error information, call
  /// `GetLastError`.
  pub(crate) fn ReadConsoleInputW(
    /* _In_  */ hConsoleInput: HANDLE,
    /* _Out_ */ lpBuffer: PINPUT_RECORD,
    /* _In_  */ nLength: u32,
    /* _Out_ */ lpNumberOfEventsRead: *mut u32,
  ) -> i32;
  /// # Return value
  ///
  /// If the function succeeds, the return value is nonzero.
  ///
  /// If the function fails, the return value is zero. To get extended error information, call
  /// `GetLastError`.
  pub(crate) fn WriteConsoleW(
    /* _In_       */ hConsoleOutput: HANDLE,
    /* _In_       */ lpBuffer: *const (),
    /* _In_       */ nNumberOfCharsToWrite: u32,
    /* _Out_opt_  */ lpNumberOfCharsWritten: *mut u32,
    /* _Reserved_ */ lpReserved: *mut (),
  ) -> i32;
  /// # Return value
  ///
  /// If the function succeeds, the return value is nonzero.
  ///
  /// If the function fails, the return value is zero. To get extended error information, call
  /// `GetLastError`.
  pub(crate) fn GetConsoleScreenBufferInfo(
    /* _In_  */ hConsoleOutput: HANDLE,
    /* _Out_ */ lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO,
  ) -> i32;
  /// # Return value
  ///
  /// If the function succeeds, the return value is nonzero.
  ///
  /// If the function fails, the return value is zero. To get extended error information, call
  /// `GetLastError`.
  pub(crate) fn SetConsoleCursorPosition(
    /* _In_ */ hConsoleOutput: HANDLE,
    /* _In_ */ dwCursorPosition: COORD,
  ) -> i32;
  /// # Return value
  ///
  /// If the function succeeds, the return value is nonzero.
  ///
  /// If the function fails, the return value is zero. To get extended error information, call
  /// `GetLastError`.
  pub(crate) fn WriteConsoleOutputW(
    /* _In_    */ hConsoleOutput: HANDLE,
    /* _In_    */ lpBuffer: *const CHAR_INFO,
    /* _In_    */ dwBufferSize: COORD,
    /* _In_    */ dwBufferCoord: COORD,
    /* _Inout_ */ lpWriteRegion: PSMALL_RECT,
  ) -> i32;
}
